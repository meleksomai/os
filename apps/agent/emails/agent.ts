import { EmailMessage } from "cloudflare:email";
import { Agent, type AgentEmail } from "agents";
import { generateText, Output } from "ai";
import { createMimeMessage } from "mimetext";
import PostalMime from "postal-mime";
import z from "zod";
import classification_email_system_prompt from "./prompts/classifier";
import draft_email_system_prompt from "./prompts/writer";
import { renderEmail } from "./templates/response-email";
import { retrieveGatewayModel } from "./utils";

export type SenderType = "self" | "agent" | "external";

/**
 * Memory of the agent.
 */
export type Memory = {
  /**
   * Last updated timestamp.
   */
  lastUpdated: Date | null;
  /**
   * Message history.
   */
  messages: Message[];
  /**
   * Context provided by Melek for more customization
   */
  context: string;
  /**
   * Summary generated by AI model. This could be triggered
   * for various cases such as context window of the LLM is exceeded.
   */
  summary: string;
};

export type Message = {
  date: Date;
  from: string;
  to: string;
  subject: string;
  raw: string | Uint8Array<ArrayBufferLike>;
  messageId: string | null;
};

export class HelloEmailAgent extends Agent<Env, Memory> {
  initialState = {
    lastUpdated: null,
    messages: [],
    context: "",
    summary: "",
  } satisfies Memory;

  async _onEmail(email: AgentEmail) {
    const triage = this.triageEmail(email);
    switch (triage) {
      case "agent":
        console.log("Email from self-agent. Ignoring to prevent loops.");
        break;

      case "self":
        console.log("Email from self. Handling as internal message.");
        break;

      case "external":
        console.log("Email from external sender. Handling accordingly.");
        await this.handleExternalEmail(email);
        break;
      default:
        console.log("Unknown sender type. Ignoring email.");
        break;
    }
  }

  async handleExternalEmail(email: AgentEmail) {
    const msg = await this.parseEmail(email);
    // Store the email message in the state of the DO.
    console.log("Storing email message in agent memory.");
    await this.store(msg);

    // Classify the email content
    console.log("Classifying email content using our AI model...");
    const classification = await this.generateEmailClassification(msg);
    console.log("Email classification:", classification);

    if (classification.action === "reply") {
      const reply = await this.generateReplyDraft(msg);
      console.log("Sending reply email...");
      await email.reply({
        from: this.env.EMAIL_ROUTING_ADDRESS,
        raw: reply,
        to: msg.from,
      });
    }

    // Forward the email to self by default.
    console.log("Forwarding email to self for record-keeping.");
    await email.forward(this.env.EMAIL_ROUTING_DESTINATION);

    // Notify self by email about the received email with personal summary.
    await this.notifySelfByEmail({
      original: email,
      content: `Received an email from ${msg.from} with subject "${msg.subject}".\n\nClassified action: ${classification.action}.\n\nComments: ${classification.comments}`,
    });

    console.log("Email processing completed.");
    return;
  }

  // !Private methods
  private async store(message: Message) {
    this.setState({
      ...this.state,
      lastUpdated: new Date(),
      messages: [...this.state.messages, message],
    });
  }

  private async parseEmail(email: AgentEmail): Promise<Message> {
    const parser = new PostalMime();
    const emailParsed = await parser.parse(await email.getRaw());

    // TODO: We can handle attachments and other content types here.

    return {
      date: new Date(),
      from: email.from,
      subject: emailParsed.subject || "(No Subject)",
      raw: emailParsed.html || emailParsed.text || "",
      to: email.to,
      messageId:
        email.headers.get("Message-ID") || emailParsed.messageId || null,
    };
  }

  private triageEmail(email: AgentEmail): SenderType {
    const from = email.from.toLowerCase();

    // Simple triage rules
    // 1. If the email is from me (likely a response), mark as self
    if (from === this.env.EMAIL_ROUTING_DESTINATION.toLowerCase()) {
      return "self";
    }

    // 2. If the email is from the routing address, mark as agent (agent replying to the thread)
    if (from === this.env.EMAIL_ROUTING_ADDRESS.toLocaleLowerCase()) {
      return "agent";
    }

    // 3. Otherwise, mark as external
    return "external";
  }

  private async notifySelfByEmail({
    original,
    content,
    contentType = "text/plain",
    inReplyTo = true,
    senderName = "Email Routing Assistant",
  }: {
    original: AgentEmail;
    content: string;
    contentType?: "text/plain" | "text/html";
    inReplyTo?: boolean;
    senderName?: string;
  }) {
    console.log("Notifying self by email with summary...");
    const msg = createMimeMessage();

    const fromAddress = this.env.EMAIL_ROUTING_ADDRESS;
    const toAddress = this.env.EMAIL_ROUTING_DESTINATION;

    if (inReplyTo) {
      // We attach the email response to the original email thread
      msg.setHeader("In-Reply-To", original.headers.get("Message-ID") || "");
    }

    msg.setSender({
      name: senderName,
      addr: fromAddress,
    });
    msg.setRecipient(toAddress);
    msg.setSubject("Email Routing Auto-reply");
    msg.addMessage({
      contentType: contentType,
      data: content,
    });

    const emailMessage = new EmailMessage(fromAddress, toAddress, msg.asRaw());

    console.log("Sending email notification to self:", toAddress);
    await this.env.SEB.send(emailMessage);
    console.log("Notification email sent to self.");
  }

  private async generateEmailClassification(message: Message) {
    console.log("Generating (LLM) the email classification...");
    const model = await retrieveGatewayModel();
    const { output } = await generateText({
      model: model,
      system: classification_email_system_prompt,
      output: Output.object({
        schema: z.object({
          intents: z
            .array(
              z.enum([
                "scheduling",
                "information_request",
                "action_request",
                "introduction_networking",
                "sales_vendor",
                "fyi_notification",
                "sensitive_legal_financial",
                "unknown_ambiguous",
              ])
            )
            .min(1),
          risk: z.enum(["low", "medium", "high"]),
          action: z.enum(["reply", "forward", "ignore"]),
          // Whether the assistant should wait for explicit user approval before sending or committing.
          requires_approval: z.boolean(),
          // A short explanation for logs and UI surfaces.
          comments: z.string().min(1).max(500),
        }),
      }),
      prompt: `Classify the following email:\n\nfrom:${message.from}\n\n subject:${message.subject}\n\n content:\n\n${message.raw}`,
    });

    return output;
  }

  private async generateReplyDraft(message: Message): Promise<string> {
    console.log("Generating (LLM) the draft reply email...");
    const model = await retrieveGatewayModel();
    const { output } = await generateText({
      model: model,
      system: draft_email_system_prompt,
      prompt: `Draft a reply to the following email:\n\nfrom:${message.from}\n\n subject:${message.subject}\n\n content:\n\n${message.raw}`,
    });
    console.log("Rendering email content...");
    const content = await renderEmail(output);

    console.log("Creating MIME message for reply...");
    const mimeMessage = createMimeMessage();

    const subject = message.subject.startsWith("Re:")
      ? message.subject
      : `Re: ${message.subject}`;

    mimeMessage.setSender({
      name: "Email Routing Assistant",
      addr: this.env.EMAIL_ROUTING_ADDRESS,
    });

    mimeMessage.setRecipient(message.from);
    mimeMessage.setSubject(subject);
    if (message.messageId) {
      mimeMessage.setHeader("In-Reply-To", message.messageId);
      mimeMessage.setHeader("References", message.messageId);
    }
    mimeMessage.addMessage({
      contentType: "text/html",
      data: content,
    });

    return mimeMessage.asRaw();
  }
}
