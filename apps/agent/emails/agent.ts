import { EmailMessage } from "cloudflare:email";
import { Agent, type AgentEmail } from "agents";
import { createMimeMessage } from "mimetext";
import PostalMime from "postal-mime";
import { classifyEmailContent } from "./models/classifier";
import { draftEmail } from "./models/writer";
import { renderEmail } from "./templates/welcome";

export type SenderType = "self" | "agent" | "external";

/**
 * Memory of the agent.
 */
export type Memory = {
  /**
   * Last updated timestamp.
   */
  lastUpdated: Date | null;
  /**
   * Message history.
   */
  messages: Message[];
  /**
   * Context provided by Melek for more customization
   */
  context: string;
  /**
   * Summary generated by AI model. This could be triggered
   * for various cases such as context window of the LLM is exceeded.
   */
  summary: string;
};

export type Message = {
  date: Date;
  from: string;
  to: string;
  subject: string;
  raw: string | Uint8Array<ArrayBufferLike>;
};

export class HelloEmailAgent extends Agent<Env, Memory> {
  initialState = {
    lastUpdated: null,
    messages: [],
    context: "",
    summary: "",
  } satisfies Memory;

  async _onEmail(email: AgentEmail) {
    const triage = this.triageEmail(email);
    if (triage === "self") {
      console.log("Email from self. Ignoring.");
      return;
    } else if (triage === "agent") {
      console.log("Email from agent itself. Ignoring.");
      return;
    } else if (triage === "external") {
      console.log("Email from external sender. Processing...");
      return this.handleExternalEmail(email);
    }
    console.log("Unknown sender type. Ignoring email.");
    return;
  }

  async handleExternalEmail(email: AgentEmail) {
    const msg = await this.parseEmail(email);
    // Store the email message in the state of the DO.
    console.log("Storing email message in agent memory.");
    await this.store(msg);

    // Classify the email content
    console.log("Classifying email content using our AI model...");
    const classification = await classifyEmailContent(msg);

    if (classification.action === "reply") {
      console.log("Drafting reply email...");
      // Draft a reply using the email writer model.
      const draft = await draftEmail(msg);
      const content = await renderEmail(draft);
      await email.reply({
        from: this.env.EMAIL_ROUTING_ADDRESS,
        raw: content,
        to: email.from,
      });
    }

    // Forward the email to self by default.
    console.log("Forwarding email to self for record-keeping.");
    await email.forward(this.env.EMAIL_ROUTING_DESTINATION);

    console.log("Email processing completed.");
    return;
  }

  // !Private methods
  private async store(message: Message) {
    this.setState({
      ...this.state,
      lastUpdated: new Date(),
      messages: [...this.state.messages, message],
    });
  }

  private async parseEmail(email: AgentEmail): Promise<Message> {
    const parser = new PostalMime();
    const emailParsed = await parser.parse(await email.getRaw());

    // TODO: We can handle attachments and other content types here.

    return {
      date: new Date(),
      from: email.from,
      subject: emailParsed.subject || "(No Subject)",
      raw: emailParsed.html || emailParsed.text || "",
      to: email.to,
    };
  }

  private triageEmail(email: AgentEmail): SenderType {
    const from = email.from.toLowerCase();

    // Simple triage rules
    // 1. If the email is from me (likely a response), mark as self
    if (from === this.env.EMAIL_ROUTING_DESTINATION.toLowerCase()) {
      return "self";
    }

    // 2. If the email is from the routing address, mark as agent (agent replying to the thread)
    if (from === this.env.EMAIL_ROUTING_ADDRESS.toLocaleLowerCase()) {
      return "agent";
    }

    // 3. Otherwise, mark as external
    return "external";
  }

  private notifySelfByEmail({
    original,
    content,
    contentType = "text/plain",
    inReplyTo = true,
    senderName,
  }: {
    original: AgentEmail;
    content: string;
    contentType: "text/plain" | "text/html";
    inReplyTo: boolean;
    senderName?: string;
  }) {
    const msg = createMimeMessage();

    if (inReplyTo) {
      // We attach the email response to the original email thread
      msg.setHeader("In-Reply-To", original.headers.get("Message-ID") || "");
    }

    msg.setSender({
      name: senderName,
      addr: original.to,
    });
    msg.setRecipient(original.from);
    msg.setSubject("Email Routing Auto-reply");
    msg.addMessage({
      contentType: contentType,
      data: content,
    });

    return new EmailMessage(original.to, original.from, msg.asRaw());
  }
}
