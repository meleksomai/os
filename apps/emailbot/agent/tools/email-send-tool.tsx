import GenericEmail from "@workspace/transactional/emails/generic";
import { tool } from "ai";
import { Resend } from "resend";
import { z } from "zod";
import type { Memory } from "../types";
import { log } from "../utils/logger";
import type { ToolResult } from "../workflows/agent";

const DEFAULT_FOOTER =
  "This message is generated by an AI assistant. It may not reflect the views of the recipient. Please verify any information before acting upon it. If you want to learn more, visit [https://github.com/meleksomai/os](https://github.com/meleksomai/os).";

const SendEmailInputSchema = z.object({
  recipient: z
    .enum(["contact", "owner", "both"])
    .describe(
      "Who to send to: contact (external person), owner (notify Melek), both (reply + cc owner)"
    ),
  subject: z.string().describe("Email subject line"),
  content: z.string().describe("Email body content"),
});

interface SendEmailData {
  id: string | null;
  error: string | null;
}

const SendOutputSchema = z.object({
  data: z.object({
    id: z.string().nullable(),
    error: z.string().nullable(),
  }),
  stateUpdates: z.record(z.string(), z.unknown()).optional(),
});

/**
 * Send email tool with recipient-based addressing.
 * Addresses resolve from state/env - AI cannot hallucinate addresses.
 */
export const sendEmailTool = (env: Env, state: Memory) =>
  tool({
    description:
      "Send an email. Choose recipient: contact (reply to external person), owner (notify Melek), both (reply + cc owner).",
    inputSchema: SendEmailInputSchema,
    outputSchema: SendOutputSchema,
    // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: it is what it is
    async execute(input): Promise<ToolResult<SendEmailData>> {
      const startTime = Date.now();
      const from = env.EMAIL_ROUTING_ADDRESS;

      // Resolve recipient(s) from state/env
      let to: string | undefined;
      let cc: string | undefined;

      switch (input.recipient) {
        case "contact":
          to = state.contact ?? undefined;
          break;
        case "owner":
          to = env.EMAIL_ROUTING_DESTINATION;
          break;
        case "both":
          to = state.contact ?? undefined;
          cc = env.EMAIL_ROUTING_DESTINATION;
          break;
        default:
          break;
      }

      if (!to) {
        log.error("[send-tool] failed", {
          error: "no contact in state",
          recipient: input.recipient,
        });
        return {
          data: { id: null, error: "No contact address available in state" },
        };
      }

      // Threading from last message
      const lastMessage = state.messages.at(-1);
      const inReplyTo = lastMessage?.messageId || "";
      const references = lastMessage?.messageId
        ? [lastMessage.messageId, ...(lastMessage.references || [])]
        : [];

      try {
        const resend = new Resend(env.RESEND_API_KEY);

        const subject = input.subject.startsWith("Re:")
          ? input.subject
          : `Re: ${input.subject}`;

        const { data, error } = await resend.emails.send({
          from,
          to,
          cc,
          subject,
          react: (
            <GenericEmail content={input.content} footer={DEFAULT_FOOTER} />
          ),
          headers: {
            "In-Reply-To": inReplyTo,
            References: references.join(" "),
          },
        });

        if (error) {
          log.error("[send-tool] failed", {
            error: error.message,
            to,
            cc,
          });
          return { data: { id: null, error: error.message } };
        }

        if (!data) {
          log.error("[send-tool] failed", {
            error: "No data returned",
            to,
          });
          return { data: { id: null, error: "No data returned from Resend" } };
        }

        log.info("[send-tool] completed", {
          emailId: data.id,
          from,
          to,
          cc,
          subject,
          inReplyTo,
          durationMs: Date.now() - startTime,
        });
        return { data: { id: data.id, error: null } };
      } catch (err) {
        log.error("[send-tool] failed", {
          error: err instanceof Error ? err.message : String(err),
          to,
        });
        return {
          data: {
            id: null,
            error: err instanceof Error ? err.message : String(err),
          },
        };
      }
    },
  });
